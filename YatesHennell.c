#define PLITHKOMV 30
#define PLITHAPOG 10

#include <stdio.h>
#include <stdlib.h>

// Για να δοθεί το αρχικό γράφημα από αρχείο, πρέπει να γίνουν κάποιες παραδοχές,
// ώστε να είναι αυτοματοποιημένος ο τρόπος που θα το δέχεται το πρόγραμμα.
// Έτσι, ας υποθέσουμε ότι το αρχείο ξεκινάει κατευθείαν με τον πρώτο κόμβο
// ακολουθούμενο από το πλήκτρο Tab και τους κόμβους με τους οποίους ενώνεται,
// χωρισμένοι με το πλήκτρο space (ένα κενό).
// Ακόμα, οι κόμβοι και οι απόγονοί τους θα είναι με αύξουσα σειρά,
// ενώ η τελευταία γραμμή θα έχει μόνο τον τελικό κόμβο. Παράδειγμα:
// 1    2 3 4
// 2    3
// 3    2 5
// 4
// Τέλος, υποθέτουμε ότι το αρχείο βρίσκεται στο ίδιο directory με το πρόγραμμα.

// Ακολουθήθηκε η εξής λογική στην ονομασία των κόμβων:
// Για κάθε κόμβο που προσπελαύνεται από δύο μονοπάτια άλλου κόμβου,
// προτιμήθηκε η ονομασία του κόμβου του προορισμού με ένα επίθεμα. Παράδειγμα,
// αν υπάρχει ένας κόμβος 3 που έχει δύο μονοπάτια που οδηγούν στον κόμβο 5,
// τα μονοπάτια αυτά θα ονομαστούν 5.1 και 5.2.

int main() {
    
    char filename[30];
    FILE *fp;
    int i, j, k, m, plith = 0, flag, p = 0, plDD = 0, plA = 0;
    float check[PLITHKOMV + 1] = {0};
    float pathsdd[PLITHKOMV + 1][PLITHAPOG + 1] = {{0}};
    float pathsft[PLITHKOMV + 1][2] = {{0}};
    struct komvos
    {
        int name;
        float apog[PLITHAPOG];
        int monadApog;
    };
    
    struct komvos komvoi[PLITHKOMV];
    
    printf("Δώσε όνομα αρχείου που περιέχει το γράφημα κόμβων\t");
    scanf("%s", filename);
    fp = fopen(filename, "r");
    
    if (fp == NULL)
    {
        printf("\nΣφάλμα κατά το άνοιγμα του αρχείου, βεβαιωθείτε ότι πληκτρολογήσατε σωστά το ");
        printf("όνομά του, καθώς και ότι βρίσκεται στο ίδιο directory με το παρόν πρόγραμμα.\n\n");
        exit(1);
    }
    /*
     // Προσπάθεια για δυναμική δέσμευση μνήμης για το πλήθος των κόμβων.
     
     // Για τον υπολογισμό του πλήθους των κόμβων, αρκεί να υπολογίσουμε τον αριθμό
     // των γραμμών του αρχείου στο οποίο περιέχονται οι συνδέσεις των κόμβων.
     
     struct komvos komv;
     int lines = 0, c;
     
     while(!feof(fp))
     {
     c = fgetc(fp);
     if(c == '\n')
     lines++;
     }
     printf("\nLines: %d\n", lines);
     
     komv = (int) malloc(lines * sizeof(int));
     */
    printf("\n-- Αρχικό γράφημα κόμβων --\n");
    // Εισαγωγή κόμβων από το αρχείο.
    for (i = 0; i < PLITHKOMV; i++)
    {
        // Ανάγνωση του πρώτου αριθμού της γραμμής, που είναι ο ίδιος ο κόμβος.
        fscanf(fp, "%d", &komvoi[i].name);
        
        printf("\nΚόμβος: %d\t", komvoi[i].name);
        
        // Ο πρώτος απόγονος:
        // (Επίσης, συνθήκη για τον τελικό κόμβο: Αν ο προηγούμενος
        // κόμβος είναι ο τελικός, σημαίνει ότι δεν υπάρχουν απόγονοι,
        // άρα παύση εισαγωγής κόμβων από το αρχείο.
        if (fscanf(fp, "%f", &komvoi[i].apog[0]) == EOF) break;
        
        printf("Απόγονοι: %.0f ", komvoi[i].apog[0]);
        
        // Έλεγχος για ύπαρξη άλλων απόγονων: Αν βρεθεί αλλαγή γραμμής,
        // δεν υπάρχουν άλλοι, ενώ όσο δεν βρίσκει αλλαγή γραμμής,
        // προσθέτει στο στέλεχος "apog" τους ευρισκόμενους απόγονους.
        for (j = 1; fgetc(fp) != '\n'; j++)
        {
            fscanf(fp, "%f", &komvoi[i].apog[j]);
            printf("%.0f ", komvoi[i].apog[j]);
        }
        
        // Προεργασία για δημιουργία DD-graph (κόμβοι
        // με έναν απόγονο δεν πρέπει να υπάρχουν).
        if (j == 1)
        {
            komvoi[i].monadApog = 1;
            plith++;
        }
        else
            komvoi[i].monadApog = 0;
        
    }
    printf("\n _________________________\n");
    
    // DD-graph
    
    // Το i έχει διατηρήσει τον αριθμό των κόμβων.
    // Η διαδικασία θα ξεκινήσει από j = 1, γιατί ο αρχικός κόμβος
    // δεν πρέπει να σβηστεί, ακόμα κι αν έχει απόγονο έναν κόμβο.
    for (j = 1; j < i; j++)
        // Εύρεση κόμβων Κ με έναν απόγονο - αν βρεθεί, τότε..
        if (komvoi[j].monadApog)
            // ..σάρωση όλων των απόγονων όλων των κόμβων, ..
            for (k = 0; k < i+1; k++)
                for (m = 0; m < PLITHAPOG; m++)
                    // ..ώστε αν βρεθεί ο Κ, ως απόγονος
                    // πλέον, άλλου κόμβου..
                    if (komvoi[k].apog[m] == komvoi[j].name)
                        // ..να αφαιρεθεί από εκεί, και τη θέση του
                        // να πάρει ο μοναδικός απόγονος του Κ.
                        komvoi[k].apog[m] = komvoi[j].apog[0];
    
    // Σβήσιμο των κόμβων με μοναδικό απόγονο.
    for (j = 1; j < i; j++)
        // Όπου βρεθεί κόμβος με μοναδικό απόγονο, ..
        if (komvoi[j].monadApog)
            // ..από εκεί και κάτω, ανεβαίνουν
            // όλοι οι κόμβοι μία θέση.
            for (k = j; k < i; k++)
                komvoi[k] = komvoi[k+1];
    
    // Μετονομασία ίδιων απόγονων σε έναν κόμβο.
    for (j = 0; j < i; j++)
        for (k = 0; komvoi[j].apog[k] != 0; k++)
            if (komvoi[j].apog[k] == komvoi[j].apog[k+1])
            {
                komvoi[j].apog[k] += 0.1;
                komvoi[j].apog[k+1] += 0.2;
            }
    
    printf("\n\t-- DD-graph --\n");
    for (j = 0; j < i - plith + 2; j++)
    {
        if (!(komvoi[j].monadApog))
        {
            printf("\nΚόμβος: %d\tΑπόγονοι: ", komvoi[j].name);
            
            for (k = 0; komvoi[j].apog[k] != 0; k++)
            {
                printf("%g ", komvoi[j].apog[k]);
                // Προεργασία για το σύνολο Α μπάρα - εισαγωγή των κόμβων
                // και των απόγονών τους ως ξεχωριστά DD μονοπάτια σε έναν
                // πίνακα, με σκοπό την σύγκρισή τους με αντίστοιχο πίνακα
                // στο Forward Tree, για την δημιουργία του συνόλου Α μπάρα.
                pathsdd[p][0] = komvoi[j].name;
                pathsdd[p++][1] = komvoi[j].apog[k];
            }
        }
    }
    // Προεργασία για την Επαλήθευση (-1 λόγω της τελευταίας φοράς
    //που δεν θα μπει στην επανάληψη, παρ'όλα αυτά θα αυξηθεί).
    plDD = j - 1;
    
    printf("\nΚόμβος: %d", komvoi[j].name);
    printf("\n _________________________\n");
    
    // Forward Tree
    
    // Αφαίρεση των διπλών μονοπατιών (θα αφαιρεθούν τυχαία τα δεύτερα).
    for (j = 0; j < i - plith + 1; j++)
        for (k = 0; komvoi[j].apog[k] != 0; k++)
            // Συνθήκη για την ύπαρξη διπλών μονοπατιών
            if ((int)komvoi[j].apog[k] == (int)komvoi[j].apog[k+1])
                // Αφαίρεση του δεύτερου μονοπατιού, αντικαθιστώντας
                // το με το επόμενο στη σειρά μονοπάτι.
                for (m = k + 1; komvoi[j].apog[m] != 0; m++)
                    komvoi[j].apog[m] = komvoi[j].apog[m+1];
    
    printf("\n\t-- F-Tree --\n");
    m = 0; p = 0;
    // Για κάθε ένα κόμβο..
    for (j = 0; j < i - plith + 2; j++)
    {
        // .. σάρωση όλων των απόγονών του..
        for (k = 0; komvoi[j].apog[k] != 0; k++)
        {
            flag = 1;
            if (!(komvoi[j].monadApog))
            {
                // .. για έλεγχο αν έχει προσπελαστεί ήδη.
                for (m = 0; check[m] != 0; m++)
                    if ((int)komvoi[j].apog[k] == check[m])
                        flag = 0;
                // Αν δεν έχει προσπελαστεί, ..
                if (flag)
                {
                    // ..εμφάνισή του στην έξοδο, ..
                    printf("\nΚόμβος: %d\tΑπόγονος: ", komvoi[j].name);
                    // .. κι εισαγωγή του στον πίνακα μοναδικών τιμών
                    // για την αποφυγή επανάληψης προσπέλασής του ξανά.
                    printf("%g ", check[m] = komvoi[j].apog[k]);
                    // Προεργασία για το σύνολο Α μπάρα
                    pathsft[p][0] = komvoi[j].name;
                    pathsft[p++][1] = komvoi[j].apog[k];
                }
            }
        }
    }
    
    printf("\nΚόμβος: %d", komvoi[j].name);
    printf("\n _________________________\n");
    
    // Backward Tree
    
    // Μηδενισμός του πίνακα check για τον σχηματισμό του B-Tree.
    for (j = 0; check[j] != 0; j++)
        check[j] = 0;
    
    // Αφαίρεση των διπλών μονοπατιών (αυτή τη φορά θα μείνουν τα δεύτερα)
    for (j = 0; j < i - plith + 2; j++)
        for (k = 0; komvoi[j].apog[k] != 0; k++)
            if ((int)komvoi[j].apog[k] != komvoi[j].apog[k])
                komvoi[j].apog[k] += 0.1;
    
    printf("\n\t-- B-Tree --\n");
    
    // Για κάθε κόμβο J αρχίζοντας από το τέλος..
    for (j = i - plith + 2; j > 0; j--)
        // ..σάρωση όλων των απόγονων..
        for (k = 0; k < i - plith + 2; k++)
            // ..όλων των κόμβων..
            for (m = 0; komvoi[k].apog[m] != 0; m++)
                if (!(komvoi[j].monadApog))
                    // ..για εύρεση κόμβου J ως απόγονο κόμβου.
                    // Αν βρεθεί, έλεγχος ότι ο πρόγονός του δεν έχει
                    // ξαναπροσπελαστεί ως πρόγονος, με τη χρήση του
                    // πίνακα check, όπου μπαίνουν μοναδικές τιμές.
                    if (komvoi[j].name == (int)komvoi[k].apog[m])
                    {
                        flag = 1;
                        for (p = 0; check[p] != 0; p++)
                            if (komvoi[k].name == check[p])
                                flag = 0;
                        if (flag)
                        {
                            printf("\nΚόμβος: %g\tΠρόγονος: ", komvoi[k].apog[m]);
                            printf("%g ", check[p] = komvoi[k].name);
                        }
                    }
    
    printf("\n _________________________\n");
    
    // Σύνολο Α μπάρα
    
    printf("\n    -- Σύνολο Α bar --\n");
    
    // Για κάθε DD μονοπάτι..
    for (j = 0; pathsdd[j][0] != 0; j++)
        // .. έλεγχος των FT μονοπατιών..
        for (k = 0; pathsft[k][0] != 0; k++)
            // .. αν είναι ίδια (και ο κόμβος, και ο απόγονος). Αν είναι ίδια, ..
            if (pathsdd[j][0] == pathsft[k][0] && pathsdd[j][1] == pathsft[k][1])
                // .. μηδενισμός αυτών των DD μονοπατιών.
                pathsdd[j][0] = pathsdd[j][1] = 0;
    
    // Οπότε, αυτά που έμειναν, είναι εκείνα που ανήκουν στο DD-graph, αλλά δεν
    // ανήκουν στο Forward Tree, δηλαδή το σύνολο των μονοπατιών του συνόλου Α μπάρα.
    // Το πλήθος των paths έχει κρατηθεί στην μεταβλητή j.
    for (k = 0; k < j; k++)
        if (pathsdd[k][0] != 0)
        {
            printf("\nΚόμβος: %g\tΑπόγονος: %g", pathsdd[k][0], pathsdd[k][1]);
            // Προεργασία για την Επαλήθευση.
            plA++;
        }
    
    printf("\n _________________________\n");
    
    // Επαλήθευση
    
    printf("\nΕπαλήθευση: e - n + 2 = πλήθος συνόλου A bar + 1 (shortest path)\n(e: αριθμός κλάδων, n: αριθμός κόμβων)");
    printf("\n\n%d - %d + 2 = %d + 1 (shortest path)\n\n", j, plDD, plA);
    
    printf("\n _________________________\n");
    
    // DD paths
    
    printf("\n\t-- DD-paths --\n");
    
    // Για την εύρεση DD μονοπατιών, θα μπορούσε:
    
    // Σάρωση όλων των απόγονων..
    for (j = 0; j < i - plith + 1; j++)
        // .. των κόμβων..
        for (k = 0; komvoi[j].apog[k] != 0; k++)
            // για την εύρεση του τελικού κόμβου
            // ως απόγονος κάποιου κόμβου Κ.
            if (komvoi[i-plith+2].name == komvoi[j].apog[k])
                printf("\nΒρέθηκε ο τελικός κόμβος: %d, ως απόγονος του: %d\n", komvoi[i-plith+2].name, komvoi[j].name);
    
    // Αφού βρεθεί ο Κ, να ξαναγίνει σάρωση όλων των απόγονων των κόμβων,
    // ψάχνοντας πια τον κόμβο Κ ως απόγονο κάποιου άλλου κόμβου.
    // (Παράδειγμα, ο τελικός κόμβος είναι ο 20, σαρώνεται όλο το διάγραμμα με σκοπό να
    // βρεθεί/-ούν ο/οι κόμβος/-οι εκείνος/-οι που έχει/-ουν ως απόγονο το 20, είναι ο 5.
    // Τώρα ξαναρχίζει η διαδικασία από την αρχή, σαρώνοντας όλο το διάγραμμα, ώστε να βρεθεί
    // ποιος/-οι κόμβος/-οι έχει/-ουν ως απόγονο το 5, και ούτω καθ'εξής, μέχρι να φτάσει
    // στον αρχικό κόμβο (1). Είναι ο 3 και ο 4. Διαλέγεται ο 3, αν η διαδικασία δεν οδηγήσει
    // στο 1, το πρόγραμμα επιστρέφει στον επόμενο κόμβο που είχε ο τελευταίος προς εξέταση
    // κόμβος ως πρόγονο, δηλαδή στο 4. Αν δεν οδηγήσει ούτε αυτός στο 1, το πρόγραμμα
    // επιστρέφει ακόμα πιο πίσω, ώστε να βρει κάποιο μονοπάτι που θα οδηγήσει τελικά στην
    // αρχή. Η διαδικασία φαίνεται εφικτή με την κατασκευή μιας recursive συνάρτησης.
    
    fclose(fp);
}
